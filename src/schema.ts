import { Type, type Static } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';

/**
 * Schema for package.json files generated by ts-base
 */
export const PackageJsonSchema = Type.Object({
  $schema: Type.Optional(Type.String()),
  name: Type.String(),
  version: Type.String(),
  description: Type.Optional(Type.String()),
  license: Type.Optional(Type.String()),
  author: Type.Optional(Type.Union([
    Type.String(),
    Type.Object({
      name: Type.String(),
      email: Type.Optional(Type.String()),
      url: Type.Optional(Type.String()),
    }),
  ])),
  type: Type.Union([Type.Literal('module'), Type.Literal('commonjs')]),
  main: Type.String(),
  types: Type.String(),
  exports: Type.Record(Type.String(), Type.Union([
    Type.String(),
    Type.Object({
      types: Type.Optional(Type.String()),
      import: Type.Optional(Type.String()),
      require: Type.Optional(Type.String()),
      default: Type.Optional(Type.String()),
    }),
  ])),
  files: Type.Array(Type.String()),
  scripts: Type.Record(Type.String(), Type.String()),
  sideEffects: Type.Boolean(),
  devDependencies: Type.Record(Type.String(), Type.String()),
  dependencies: Type.Record(Type.String(), Type.String()),
  peerDependencies: Type.Record(Type.String(), Type.String()),
  keywords: Type.Array(Type.String()),
  repository: Type.Object({
    type: Type.String(),
    url: Type.String(),
  }),
  bugs: Type.Object({
    url: Type.String(),
  }),
  homepage: Type.String(),
  publishConfig: Type.Object({
    access: Type.Union([Type.Literal('public'), Type.Literal('restricted')]),
  }),
  engines: Type.Object({
    node: Type.String(),
    npm: Type.Optional(Type.String()),
  }),
});

export type PackageJson = Static<typeof PackageJsonSchema>;

/**
 * Schema for tsconfig.json files generated by ts-base
 */
export const TsconfigSchema = Type.Object({
  $schema: Type.Optional(Type.String()),
  extends: Type.String(),
  compilerOptions: Type.Optional(Type.Record(Type.String(), Type.Unknown())),
  include: Type.Optional(Type.Array(Type.String())),
  exclude: Type.Optional(Type.Array(Type.String())),
});

export type Tsconfig = Static<typeof TsconfigSchema>;

/**
 * Validate a value against a TypeBox schema
 */
export function validate<T>(schema: ReturnType<typeof Type.Object>, value: unknown): value is T {
  return Value.Check(schema, value);
}

/**
 * Get validation errors for a value against a TypeBox schema
 */
export function getErrors(schema: ReturnType<typeof Type.Object>, value: unknown): string[] {
  const errors = [...Value.Errors(schema, value)];
  return errors.map((e) => `${e.path}: ${e.message}`);
}
